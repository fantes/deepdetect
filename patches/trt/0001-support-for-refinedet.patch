diff --git a/include/NvInferPluginUtils.h b/include/NvInferPluginUtils.h
index f9c9455..ea2a06e 100644
--- a/include/NvInferPluginUtils.h
+++ b/include/NvInferPluginUtils.h
@@ -158,9 +158,9 @@ struct DetectionOutputParameters
 {
     bool shareLocation, varianceEncodedInTarget;
     int32_t backgroundLabelId, numClasses, topK, keepTopK;
-    float confidenceThreshold, nmsThreshold;
+    float confidenceThreshold, nmsThreshold, objectnessScore;
     CodeTypeSSD codeType;
-    int32_t inputOrder[3];
+    int32_t inputOrder[5];
     bool confSigmoid;
     bool isNormalized;
     bool isBatchAgnostic{true};
diff --git a/parsers/caffe/caffeParser/caffeParser.cpp b/parsers/caffe/caffeParser/caffeParser.cpp
index 76bbc97..a30ce55 100644
--- a/parsers/caffe/caffeParser/caffeParser.cpp
+++ b/parsers/caffe/caffeParser/caffeParser.cpp
@@ -195,12 +195,19 @@ std::vector<nvinfer1::PluginField> CaffeParser::parseDetectionOutputParam(const
     *nmsThreshold = nmsp.nms_threshold();
     f.emplace_back("nmsThreshold", nmsThreshold, PluginFieldType::kFLOAT32, 1);
 
+    // objecteness score for ARM
+    auto* objectnessScore = allocMemory<float>();
+    *objectnessScore = p.objectness_score();
+    f.emplace_back("objectnessScore", objectnessScore, PluginFieldType::kFLOAT32, 1);
+
     // input order = {0, 1, 2} in Caffe
-    int* inputOrder = allocMemory<int32_t>(3);
+    int* inputOrder = allocMemory<int32_t>(5);
     inputOrder[0] = 0;
     inputOrder[1] = 1;
     inputOrder[2] = 2;
-    f.emplace_back("inputOrder", inputOrder, PluginFieldType::kINT32, 3);
+    inputOrder[3] = 3;
+    inputOrder[4] = 4;
+    f.emplace_back("inputOrder", inputOrder, PluginFieldType::kINT32, 5);
 
     // confSigmoid = false for Caffe
     int* confSigmoid = allocMemory<int32_t>();
diff --git a/parsers/caffe/proto/trtcaffe.proto b/parsers/caffe/proto/trtcaffe.proto
index 059f932..0ef9b6b 100644
--- a/parsers/caffe/proto/trtcaffe.proto
+++ b/parsers/caffe/proto/trtcaffe.proto
@@ -980,6 +980,8 @@ message DetectionOutputParameter {
   // Only consider detections whose confidences are larger than a threshold.
   // If not provided, consider all boxes.
   optional float confidence_threshold = 9;
+  // the objectness score is used for the anchor refinement module to filter easy negative anchor.
+  optional float objectness_score = 13 [default = 0.01];
   // If true, visualize the detection results.
   optional bool visualize = 10 [default = false];
   // The threshold used to visualize the detection results.
diff --git a/plugin/common/kernel.h b/plugin/common/kernel.h
index f832812..85f3d7d 100644
--- a/plugin/common/kernel.h
+++ b/plugin/common/kernel.h
@@ -42,8 +42,9 @@ pluginStatus_t allClassNMS(cudaStream_t stream, int num, int num_classes, int nu
 
 pluginStatus_t detectionInference(cudaStream_t stream, int N, int C1, int C2, bool shareLocation,
     bool varianceEncodedInTarget, int backgroundLabelId, int numPredsPerClass, int numClasses, int topK, int keepTopK,
-    float confidenceThreshold, float nmsThreshold, CodeTypeSSD codeType, DataType DT_BBOX, const void* locData,
-    const void* priorData, DataType DT_SCORE, const void* confData, void* keepCount, void* topDetections,
+    float confidenceThreshold, float nmsThreshold, float objectnessScore, CodeTypeSSD codeType, DataType DT_BBOX, const void* locData,
+    const void* priorData, DataType DT_SCORE, const void* confData, const void* arm_conf_data,
+    const void* arm_loc_data, void* keepCount, void* topDetections,
     void* workspace, bool isNormalized = true, bool confSigmoid = false, int scoreBits = 16, const bool isBatchAgnostic = true);
 
 pluginStatus_t nmsInference(cudaStream_t stream, int N, int boxesSize, int scoresSize, bool shareLocation,
@@ -79,13 +80,16 @@ const char* cublasGetErrorString(cublasStatus_t error);
 pluginStatus_t permuteData(cudaStream_t stream, int nthreads, int num_classes, int num_data, int num_dim,
     DataType DT_DATA, bool confSigmoid, const void* data, void* new_data);
 
+pluginStatus_t OSPermuteData(cudaStream_t stream, int nthreads, int num_classes, int num_data, int num_dim,
+    DataType DT_DATA, bool confSigmoid, const void* data, const void* arm_data, float objectness_score, void* new_data);
+
 size_t detectionForwardPreNMSSize(int N, int C2);
 
 size_t detectionForwardPostNMSSize(int N, int numClasses, int topK);
 
 pluginStatus_t decodeBBoxes(cudaStream_t stream, int nthreads, CodeTypeSSD code_type, bool variance_encoded_in_target,
     int num_priors, bool share_location, int num_loc_classes, int background_label_id, bool clip_bbox, DataType DT_BBOX,
-    const void* loc_data, const void* prior_data, void* bbox_data, const bool batch_agnostic);
+    const void* loc_data, const void* prior_data, const void* arm_loc_data, void* bbox_data, const bool batch_agnostic);
 
 size_t normalizePluginWorkspaceSize(bool acrossSpatial, int C, int H, int W);
 
diff --git a/plugin/common/kernels/decodeBBoxes.cu b/plugin/common/kernels/decodeBBoxes.cu
index 8a689c1..087250a 100644
--- a/plugin/common/kernels/decodeBBoxes.cu
+++ b/plugin/common/kernels/decodeBBoxes.cu
@@ -284,6 +284,132 @@ __launch_bounds__(nthds_per_cta)
     }
 }
 
+template <typename T_BBOX, unsigned nthds_per_cta>
+__launch_bounds__(nthds_per_cta)
+    __global__ void CasReg_decodeBBoxes_kernel(
+        const int nthreads,
+        const CodeTypeSSD code_type,
+        const bool variance_encoded_in_target,
+        const int num_priors,
+        const bool share_location,
+        const int num_loc_classes,
+        const int background_label_id,
+        const bool clip_bbox,
+        const T_BBOX* loc_data,
+        const T_BBOX* prior_data,
+        T_BBOX* bbox_data)
+{
+    for (int index = blockIdx.x * nthds_per_cta + threadIdx.x; index < nthreads; index += nthds_per_cta * gridDim.x)
+    {
+        const int i = index % 4;
+        const int c = (index / 4) % num_loc_classes;
+        const int d = (index / 4 / num_loc_classes) % num_priors;
+        if (!share_location && c == background_label_id)
+        {
+            // Ignore background class if not share_location.
+            return;
+        }
+        const int pi = d * 4;
+        const int vi = pi + num_priors * 4;
+        if (code_type == CodeTypeSSD::CORNER)
+        {
+            if (variance_encoded_in_target)
+            {
+                // variance is encoded in target, we simply need to add the offset
+                // predictions.
+                bbox_data[index] = bbox_data[index] + loc_data[index];
+            }
+            else
+            {
+                // variance is encoded in bbox, we need to scale the offset accordingly.
+                bbox_data[index] = bbox_data[index] + loc_data[index] * prior_data[vi + i];
+            }
+        }
+        else if (code_type == CodeTypeSSD::CENTER_SIZE)
+        {
+            const T_BBOX p_xmin = bbox_data[index - i];
+            const T_BBOX p_ymin = bbox_data[index - i + 1];
+            const T_BBOX p_xmax = bbox_data[index - i + 2];
+            const T_BBOX p_ymax = bbox_data[index - i + 3];
+            const T_BBOX prior_width = p_xmax - p_xmin;
+            const T_BBOX prior_height = p_ymax - p_ymin;
+            const T_BBOX prior_center_x = (p_xmin + p_xmax) / 2.;
+            const T_BBOX prior_center_y = (p_ymin + p_ymax) / 2.;
+
+            const T_BBOX xmin = loc_data[index - i];
+            const T_BBOX ymin = loc_data[index - i + 1];
+            const T_BBOX xmax = loc_data[index - i + 2];
+            const T_BBOX ymax = loc_data[index - i + 3];
+
+            T_BBOX decode_bbox_center_x, decode_bbox_center_y;
+            T_BBOX decode_bbox_width, decode_bbox_height;
+            if (variance_encoded_in_target)
+            {
+                // variance is encoded in target, we simply need to retore the offset
+                // predictions.
+                decode_bbox_center_x = xmin * prior_width + prior_center_x;
+                decode_bbox_center_y = ymin * prior_height + prior_center_y;
+                decode_bbox_width = exp(xmax) * prior_width;
+                decode_bbox_height = exp(ymax) * prior_height;
+            }
+            else
+            {
+                // variance is encoded in bbox, we need to scale the offset accordingly.
+                decode_bbox_center_x = prior_data[vi] * xmin * prior_width + prior_center_x;
+                decode_bbox_center_y = prior_data[vi + 1] * ymin * prior_height + prior_center_y;
+                decode_bbox_width = exp(prior_data[vi + 2] * xmax) * prior_width;
+                decode_bbox_height = exp(prior_data[vi + 3] * ymax) * prior_height;
+            }
+
+            switch (i)
+            {
+            case 0: bbox_data[index] = decode_bbox_center_x - decode_bbox_width / 2.; break;
+            case 1: bbox_data[index] = decode_bbox_center_y - decode_bbox_height / 2.; break;
+            case 2: bbox_data[index] = decode_bbox_center_x + decode_bbox_width / 2.; break;
+            case 3: bbox_data[index] = decode_bbox_center_y + decode_bbox_height / 2.; break;
+            }
+        }
+        else if (code_type == CodeTypeSSD::CORNER_SIZE)
+        {
+            const T_BBOX p_xmin = bbox_data[index - i];
+            const T_BBOX p_ymin = bbox_data[index - i + 1];
+            const T_BBOX p_xmax = bbox_data[index - i + 2];
+            const T_BBOX p_ymax = bbox_data[index - i + 3];
+            const T_BBOX prior_width = p_xmax - p_xmin;
+            const T_BBOX prior_height = p_ymax - p_ymin;
+            T_BBOX p_size;
+            if (i == 0 || i == 2)
+            {
+                p_size = prior_width;
+            }
+            else
+            {
+                p_size = prior_height;
+            }
+            if (variance_encoded_in_target)
+            {
+                // variance is encoded in target, we simply need to add the offset
+                // predictions.
+                bbox_data[index] = bbox_data[index] + loc_data[index] * p_size;
+            }
+            else
+            {
+                // variance is encoded in bbox, we need to scale the offset accordingly.
+                bbox_data[index] = bbox_data[index] + loc_data[index] * prior_data[vi + i] * p_size;
+            }
+        }
+        else
+        {
+            // Unknown code type.
+        }
+        if (clip_bbox)
+        {
+            bbox_data[index] = max(min(bbox_data[index], T_BBOX(1.)), T_BBOX(0.));
+        }
+    }
+}
+
+
 template <typename T_BBOX>
 pluginStatus_t decodeBBoxes_gpu(
     cudaStream_t stream,
@@ -297,16 +423,32 @@ pluginStatus_t decodeBBoxes_gpu(
     const bool clip_bbox,
     const void* loc_data,
     const void* prior_data,
+    const void* arm_loc_data,
     void* bbox_data,
     const bool batch_agnostic)
 {
     const int BS = 512;
     const int GS = (nthreads + BS - 1) / BS;
-    decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>(nthreads, code_type, variance_encoded_in_target,
-                                                           num_priors, share_location, num_loc_classes,
-                                                           background_label_id, clip_bbox,
-                                                           (const T_BBOX*) loc_data, (const T_BBOX*) prior_data,
-                                                           (T_BBOX*) bbox_data, batch_agnostic);
+    if (arm_loc_data == NULL)
+       decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>
+         (nthreads, code_type, variance_encoded_in_target,
+          num_priors, share_location, num_loc_classes,
+          background_label_id, clip_bbox,
+          (const T_BBOX*) loc_data, (const T_BBOX*) prior_data,
+          (T_BBOX*) bbox_data, batch_agnostic);
+    else
+    {
+         decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>
+           (nthreads, code_type, variance_encoded_in_target,
+            num_priors, share_location, num_loc_classes, background_label_id, clip_bbox,
+            (const T_BBOX*) arm_loc_data,
+            (const T_BBOX*) prior_data, (T_BBOX*) bbox_data, batch_agnostic);
+         CasReg_decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>
+           (nthreads, code_type, variance_encoded_in_target,
+            num_priors, share_location, num_loc_classes, background_label_id,
+            clip_bbox, (const T_BBOX*) loc_data,
+            (const T_BBOX*) prior_data, (T_BBOX*) bbox_data);
+    }
     CSC(cudaGetLastError(), STATUS_FAILURE);
     return STATUS_SUCCESS;
 }
@@ -323,6 +465,7 @@ typedef pluginStatus_t (*dbbFunc)(cudaStream_t,
                                const bool,
                                const void*,
                                const void*,
+                               const void*,
                                void*,
                                const bool);
 
@@ -346,9 +489,8 @@ struct dbbLaunchConfig
     }
 };
 
-static std::array<dbbLaunchConfig, 2> dbbLCOptions = {
-    dbbLaunchConfig(DataType::kFLOAT, decodeBBoxes_gpu<float>),
-    dbbLaunchConfig(DataType::kHALF, decodeBBoxes_gpu<__half>)
+static std::array<dbbLaunchConfig, 1> dbbLCOptions = {
+    dbbLaunchConfig(DataType::kFLOAT, decodeBBoxes_gpu<float>)
 };
 
 pluginStatus_t decodeBBoxes(
@@ -364,6 +506,7 @@ pluginStatus_t decodeBBoxes(
     const DataType DT_BBOX,
     const void* loc_data,
     const void* prior_data,
+	const void* arm_loc_data,
     void* bbox_data,
     const bool batch_agnostic)
 {
@@ -384,6 +527,7 @@ pluginStatus_t decodeBBoxes(
                                           clip_bbox,
                                           loc_data,
                                           prior_data,
+                                          arm_loc_data,
                                           bbox_data,
                                           batch_agnostic);
         }
diff --git a/plugin/common/kernels/detectionForward.cu b/plugin/common/kernels/detectionForward.cu
index f0398eb..9e17fa2 100644
--- a/plugin/common/kernels/detectionForward.cu
+++ b/plugin/common/kernels/detectionForward.cu
@@ -30,12 +30,15 @@ pluginStatus_t detectionInference(
     const int keepTopK,
     const float confidenceThreshold,
     const float nmsThreshold,
+	const float objectnessScore,
     const CodeTypeSSD codeType,
     const DataType DT_BBOX,
     const void* locData,
     const void* priorData,
     const DataType DT_SCORE,
     const void* confData,
+	const void* arm_confData,
+	const void* arm_locData,
     void* keepCount,
     void* topDetections,
     void* workspace,
@@ -71,6 +74,7 @@ pluginStatus_t detectionInference(
                                       DT_BBOX,
                                       locData,
                                       priorData,
+                                      arm_locData,
                                       bboxDataRaw,
                                       isBatchAgnostic);
 
@@ -125,15 +129,29 @@ pluginStatus_t detectionInference(
      * After permutation, confData format:
      * [batch_size, numClasses, numPredsPerClass, 1]
      */
-    status = permuteData(stream,
-                         numScores,
-                         numClasses,
-                         numPredsPerClass,
-                         1,
-                         DT_SCORE,
-                         confSigmoid,
-                         confData,
-                         scores);
+    if (arm_confData == NULL)
+      status = permuteData(stream,
+                           numScores,
+                           numClasses,
+                           numPredsPerClass,
+                           1,
+                           DT_SCORE,
+                           confSigmoid,
+                           confData,
+                           scores);
+    else
+      status = OSPermuteData(stream,
+							 numScores,
+							 numClasses,
+							 numPredsPerClass,
+							 1,
+							 DataType::kFLOAT,
+							 confSigmoid,
+							 confData,
+							 arm_confData,
+							 objectnessScore,
+							 scores);
+
     ASSERT_FAILURE(status == STATUS_SUCCESS);
 
     size_t indicesSize = detectionForwardPreNMSSize(N, C2);
@@ -244,6 +262,8 @@ namespace plugin
     const void* priorData,
     const DataType DT_SCORE,
     const void* confData,
+    const void* arm_confData,
+	const void* arm_locData,
     void* keepCount,
     void* topDetections,
     void* workspace,
@@ -278,6 +298,7 @@ namespace plugin
                                       clipBBox,
                                       DT_BBOX,
                                       locData,
+                                      arm_locData,
                                       priorData,
                                       bboxDataRaw,
                                       isBatchAgnostic);
diff --git a/plugin/common/kernels/permuteData.cu b/plugin/common/kernels/permuteData.cu
index 06d28ef..eeee24c 100644
--- a/plugin/common/kernels/permuteData.cu
+++ b/plugin/common/kernels/permuteData.cu
@@ -16,6 +16,139 @@
 #include <array>
 #include "kernel.h"
 
+template <typename Dtype, unsigned nthds_per_cta>
+__launch_bounds__(nthds_per_cta)
+    __global__ void OSPermuteData_kernel(
+        const int nthreads,
+        const int num_classes,
+        const int num_data,
+        const int num_dim,
+        bool confSigmoid,
+        const Dtype* data,
+		const Dtype* arm_data,
+		float objectness_score,
+        Dtype* new_data)
+{
+    // data format: [batch_size, num_data, num_classes, num_dim]
+    for (int index = blockIdx.x * nthds_per_cta + threadIdx.x;
+         index < nthreads;
+         index += nthds_per_cta * gridDim.x)
+    {
+        const int i = index % num_dim;
+        const int c = (index / num_dim) % num_classes;
+        const int d = (index / num_dim / num_classes) % num_data;
+        const int n = index / num_dim / num_classes / num_data;
+        const int new_index = ((n * num_classes + c) * num_data + d) * num_dim + i;
+
+		const int arm_index = ((n * num_data + d) * 2 + 1) * num_dim + i;
+		if (arm_data[arm_index] < objectness_score)
+		  {
+			if (c==0)
+			  new_data[new_index] = 1.0;
+			else
+			  new_data[new_index] = 0.0;
+		  }
+		else
+		  {
+			float result = data[index];
+			if (confSigmoid)
+			  result = exp(result) / (1 + exp(result));
+			new_data[new_index] = result;
+		  }
+    }
+    // new data format: [batch_size, num_classes, num_data, num_dim]
+}
+
+template <typename Dtype>
+pluginStatus_t OSPermuteData_gpu(
+    cudaStream_t stream,
+    const int nthreads,
+    const int num_classes,
+    const int num_data,
+    const int num_dim,
+    bool confSigmoid,
+    const void* data,
+	const void* arm_data,
+	float objectness_score,
+    void* new_data)
+{
+    const int BS = 512;
+    const int GS = (nthreads + BS - 1) / BS;
+    OSPermuteData_kernel<Dtype, BS><<<GS, BS, 0, stream>>>(nthreads, num_classes, num_data, num_dim, confSigmoid,
+                                                         (const Dtype*) data, (const Dtype*) arm_data, objectness_score, (Dtype*) new_data);
+    CSC(cudaGetLastError(), STATUS_FAILURE);
+    return STATUS_SUCCESS;
+}
+// permuteData LAUNCH CONFIG
+typedef pluginStatus_t (*ospdFunc)(cudaStream_t,
+								   const int,
+								   const int,
+								   const int,
+								   const int,
+								   bool,
+								   const void*,
+								   const void*,
+								   const float,
+								   void*);
+
+struct ospdLaunchConfig
+{
+    DataType t_data;
+    ospdFunc function;
+
+    ospdLaunchConfig(DataType t_data)
+        : t_data(t_data)
+    {
+    }
+    ospdLaunchConfig(DataType t_data, ospdFunc function)
+        : t_data(t_data)
+        , function(function)
+    {
+    }
+    bool operator==(const ospdLaunchConfig& other)
+    {
+        return t_data == other.t_data;
+    }
+};
+
+static std::array<ospdLaunchConfig,1> ospdLCOptions = {
+  ospdLaunchConfig(DataType::kFLOAT, OSPermuteData_gpu<float>)
+};
+
+pluginStatus_t OSPermuteData(cudaStream_t stream,
+                        const int nthreads,
+                        const int num_classes,
+                        const int num_data,
+                        const int num_dim,
+                        const DataType DT_DATA,
+                        bool confSigmoid,
+                        const void* data,
+						const void * arm_data,
+						float objectness_score,
+                        void* new_data)
+{
+    ospdLaunchConfig lc = ospdLaunchConfig(DT_DATA);
+    for (unsigned i = 0; i < ospdLCOptions.size(); ++i)
+    {
+        if (lc == ospdLCOptions[i])
+        {
+            DEBUG_PRINTF("permuteData kernel %d\n", i);
+            return ospdLCOptions[i].function(stream,
+										   nthreads,
+										   num_classes,
+										   num_data,
+										   num_dim,
+										   confSigmoid,
+										   data,
+										   arm_data,
+										 objectness_score,
+										   new_data);
+        }
+    }
+    return STATUS_BAD_PARAM;
+}
+
+
 template <typename Dtype, unsigned nthds_per_cta>
 __launch_bounds__(nthds_per_cta)
     __global__ void permuteData_kernel(
@@ -88,8 +221,9 @@ struct pdLaunchConfig
     }
 };
 
-static std::array<pdLaunchConfig, 2> pdLCOptions = {
-    pdLaunchConfig(DataType::kFLOAT, permuteData_gpu<float>), pdLaunchConfig(DataType::kHALF, permuteData_gpu<__half>)};
+static std::array<pdLaunchConfig, 1> pdLCOptions = {
+    pdLaunchConfig(DataType::kFLOAT, permuteData_gpu<float>)
+};
 
 pluginStatus_t permuteData(cudaStream_t stream, const int nthreads, const int num_classes, const int num_data,
     const int num_dim, const DataType DT_DATA, bool confSigmoid, const void* data, void* new_data)
diff --git a/plugin/nmsPlugin/nmsPlugin.cpp b/plugin/nmsPlugin/nmsPlugin.cpp
index cc1944a..3d30c19 100644
--- a/plugin/nmsPlugin/nmsPlugin.cpp
+++ b/plugin/nmsPlugin/nmsPlugin.cpp
@@ -44,6 +44,7 @@ DetectionOutput::DetectionOutput(DetectionOutputParameters params)
     , numPriors(0)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(false)
 {
 }
 
@@ -54,26 +55,30 @@ DetectionOutputDynamic::DetectionOutputDynamic(DetectionOutputParameters params)
     , numPriors(0)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(false)
 {
 }
 
-DetectionOutput::DetectionOutput(DetectionOutputParameters params, int C1, int C2, int numPriors)
+DetectionOutput::DetectionOutput(DetectionOutputParameters params, int C1, int C2, int numPriors, bool ARM)
     : param(params)
     , C1(C1)
     , C2(C2)
     , numPriors(numPriors)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(ARM)
 {
 }
 
-DetectionOutputDynamic::DetectionOutputDynamic(DetectionOutputParameters params, int C1, int C2, int numPriors)
+DetectionOutputDynamic::DetectionOutputDynamic(
+    DetectionOutputParameters params, int C1, int C2, int numPriors, bool ARM)
     : param(params)
     , C1(C1)
     , C2(C2)
     , numPriors(numPriors)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(ARM)
 {
 }
 
@@ -90,6 +95,11 @@ DetectionOutput::DetectionOutput(const void* data, size_t length)
     C2 = read<int>(d);
     // Number of bounding boxes per sample
     numPriors = read<int>(d);
+    int arm = read<int>(d);
+    if (arm == 0)
+        _ARM = false;
+    else
+        _ARM = true;
     // data type of this plugin
     mType = read<DataType>(d);
     // mScoreBits
@@ -109,6 +119,11 @@ DetectionOutputDynamic::DetectionOutputDynamic(const void* data, size_t length)
     C2 = read<int>(d);
     // Number of bounding boxes per sample
     numPriors = read<int>(d);
+    int arm = read<int>(d);
+    if (arm == 0)
+        _ARM = false;
+    else
+        _ARM = true;
     // data type of this plugin
     mType = read<DataType>(d);
     // mScoreBits
@@ -145,7 +160,7 @@ void DetectionOutputDynamic::terminate() noexcept {}
 // Returns output dimensions at given index
 Dims DetectionOutput::getOutputDimensions(int index, const Dims* inputs, int nbInputDims) noexcept
 {
-    ASSERT(nbInputDims == 3);
+    ASSERT(nbInputDims == 3 || nbInputDims == 5);
     ASSERT(index == 0 || index == 1);
     // Output dimensions
     // index 0 : Dimensions 1x param.keepTopK x 7
@@ -160,7 +175,7 @@ Dims DetectionOutput::getOutputDimensions(int index, const Dims* inputs, int nbI
 DimsExprs DetectionOutputDynamic::getOutputDimensions(
     int outputIndex, const DimsExprs* inputs, int nbInputs, IExprBuilder& exprBuilder) noexcept
 {
-    ASSERT(nbInputs == 3);
+    ASSERT(nbInputs == 3 || nbInputs == 5);
     ASSERT(outputIndex >= 0 && outputIndex < this->getNbOutputs());
     // loc data
     ASSERT(inputs[0].nbDims == 4);
@@ -229,8 +244,16 @@ int DetectionOutput::enqueue(
 {
     // Input order {loc, conf, prior}
     const void* const locData = inputs[param.inputOrder[0]];
-    const void* const confData = inputs[param.inputOrder[1]];
-    const void* const priorData = inputs[param.inputOrder[2]];
+    const void* confData = inputs[param.inputOrder[1]];
+    const void* priorData = inputs[param.inputOrder[2]];
+    const void* arm_conf_data = NULL;
+    const void* arm_loc_data = NULL;
+
+    if (_ARM)
+    {
+        arm_conf_data = inputs[param.inputOrder[3]];
+        arm_loc_data = inputs[param.inputOrder[4]];
+    }
 
     // Output from plugin index 0: topDetections index 1: keepCount
     void* topDetections = outputs[0];
@@ -238,8 +261,9 @@ int DetectionOutput::enqueue(
 
     pluginStatus_t status = detectionInference(stream, batchSize, C1, C2, param.shareLocation,
         param.varianceEncodedInTarget, param.backgroundLabelId, numPriors, param.numClasses, param.topK, param.keepTopK,
-        param.confidenceThreshold, param.nmsThreshold, param.codeType, mType, locData, priorData, mType, confData,
-        keepCount, topDetections, workspace, param.isNormalized, param.confSigmoid, mScoreBits, param.isBatchAgnostic);
+        param.confidenceThreshold, param.nmsThreshold, param.objectnessScore, param.codeType, mType, locData, priorData,
+        mType, confData, arm_conf_data, arm_loc_data, keepCount, topDetections, workspace, param.isNormalized,
+        param.confSigmoid, mScoreBits, param.isBatchAgnostic);
     return status;
 }
 
@@ -248,8 +272,16 @@ int32_t DetectionOutputDynamic::enqueue(const PluginTensorDesc* inputDesc, const
 {
     // Input order {loc, conf, prior}
     const void* const locData = inputs[param.inputOrder[0]];
-    const void* const confData = inputs[param.inputOrder[1]];
-    const void* const priorData = inputs[param.inputOrder[2]];
+    const void* confData = inputs[param.inputOrder[1]];
+    const void* priorData = inputs[param.inputOrder[2]];
+    const void* arm_conf_data = NULL;
+    const void* arm_loc_data = NULL;
+
+    if (_ARM)
+    {
+        arm_conf_data = inputs[param.inputOrder[3]];
+        arm_loc_data = inputs[param.inputOrder[4]];
+    }
 
     // Output from plugin index 0: topDetections index 1: keepCount
     void* topDetections = outputs[0];
@@ -257,8 +289,9 @@ int32_t DetectionOutputDynamic::enqueue(const PluginTensorDesc* inputDesc, const
 
     pluginStatus_t status = detectionInference(stream, inputDesc[0].dims.d[0], C1, C2, param.shareLocation,
         param.varianceEncodedInTarget, param.backgroundLabelId, numPriors, param.numClasses, param.topK, param.keepTopK,
-        param.confidenceThreshold, param.nmsThreshold, param.codeType, mType, locData, priorData, mType, confData,
-        keepCount, topDetections, workspace, param.isNormalized, param.confSigmoid, mScoreBits, false);
+        param.confidenceThreshold, param.nmsThreshold, param.objectnessScore, param.codeType, mType, locData, priorData,
+        mType, confData, arm_conf_data, arm_loc_data, keepCount, topDetections, workspace, param.isNormalized,
+        param.confSigmoid, mScoreBits, false);
     return status;
 }
 
@@ -266,13 +299,13 @@ int32_t DetectionOutputDynamic::enqueue(const PluginTensorDesc* inputDesc, const
 size_t DetectionOutput::getSerializationSize() const noexcept
 {
     // DetectionOutputParameters, C1, C2, numPriors, mType, mScoreBits
-    return sizeof(DetectionOutputParameters) + sizeof(int) * 3 + sizeof(DataType) + sizeof(int32_t);
+    return sizeof(DetectionOutputParameters) + sizeof(int) * 4 + sizeof(DataType) + sizeof(int32_t);
 }
 
 size_t DetectionOutputDynamic::getSerializationSize() const noexcept
 {
     // DetectionOutputParameters, C1, C2, numPriors, mType, mScoreBits
-    return sizeof(DetectionOutputParameters) + sizeof(int) * 3 + sizeof(DataType) + sizeof(int32_t);
+    return sizeof(DetectionOutputParameters) + sizeof(int) * 4 + sizeof(DataType) + sizeof(int32_t);
 }
 
 // Serialization of plugin parameters
@@ -283,6 +316,10 @@ void DetectionOutput::serialize(void* buffer) const noexcept
     write(d, C1);
     write(d, C2);
     write(d, numPriors);
+    if (_ARM)
+        write(d, (int) 1);
+    else
+        write(d, (int) 0);
     write(d, mType);
     write(d, mScoreBits);
     ASSERT(d == a + getSerializationSize());
@@ -295,6 +332,10 @@ void DetectionOutputDynamic::serialize(void* buffer) const noexcept
     write(d, C1);
     write(d, C2);
     write(d, numPriors);
+    if (_ARM)
+        write(d, (int) 1);
+    else
+        write(d, (int) 0);
     write(d, mType);
     write(d, mScoreBits);
     ASSERT(d == a + getSerializationSize());
@@ -310,25 +351,25 @@ bool DetectionOutputDynamic::supportsFormatCombination(
     int pos, const PluginTensorDesc* inOut, int nbInputs, int nbOutputs) noexcept
 {
     // 3 inputs, 2 outputs, so 5 input/output in total
-    ASSERT(0 <= pos && pos < 5);
+    ASSERT(0 <= pos && pos < 7);
     const auto* in = inOut;
     const auto* out = inOut + nbInputs;
     const bool consistentFloatPrecision = (in[0].type == in[pos].type);
     switch (pos)
     {
     case 0:
-        return (in[0].type == DataType::kHALF || in[0].type == DataType::kFLOAT)
-            && in[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+        return (in[0].type == DataType::kFLOAT) && in[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
     case 1:
-        return (in[1].type == DataType::kHALF || in[1].type == DataType::kFLOAT)
-            && in[1].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+        return (in[1].type == DataType::kFLOAT) && in[1].format == PluginFormat::kLINEAR && consistentFloatPrecision;
     case 2:
-        return (in[2].type == DataType::kHALF || in[2].type == DataType::kFLOAT)
-            && in[2].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+        return (in[2].type == DataType::kFLOAT) && in[2].format == PluginFormat::kLINEAR && consistentFloatPrecision;
     case 3:
-        return (out[0].type == DataType::kHALF || out[0].type == DataType::kFLOAT)
-            && out[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
-    case 4: return out[1].type == DataType::kFLOAT && out[1].format == PluginFormat::kLINEAR;
+        return (in[3].type == DataType::kFLOAT) && in[3].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+    case 4:
+        return (in[4].type == DataType::kFLOAT) && in[4].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+    case 5:
+        return (out[0].type == DataType::kFLOAT) && out[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+    case 6: return out[1].type == DataType::kFLOAT && out[1].format == PluginFormat::kLINEAR;
     }
     return false;
 }
@@ -380,7 +421,7 @@ void DetectionOutputDynamic::setScoreBits(int32_t scoreBits) noexcept
 IPluginV2Ext* DetectionOutput::clone() const noexcept
 {
     // Create a new instance
-    auto* plugin = new DetectionOutput(param, C1, C2, numPriors);
+    auto* plugin = new DetectionOutput(param, C1, C2, numPriors, _ARM);
     plugin->mType = mType;
     // Set the namespace
     plugin->setPluginNamespace(mPluginNamespace.c_str());
@@ -392,7 +433,7 @@ IPluginV2Ext* DetectionOutput::clone() const noexcept
 IPluginV2DynamicExt* DetectionOutputDynamic::clone() const noexcept
 {
     // Create a new instance
-    auto* plugin = new DetectionOutputDynamic(param, C1, C2, numPriors);
+    auto* plugin = new DetectionOutputDynamic(param, C1, C2, numPriors, _ARM);
     plugin->mType = mType;
     // Set the namespace
     plugin->setPluginNamespace(mPluginNamespace.c_str());
@@ -423,31 +464,33 @@ const char* DetectionOutputDynamic::getPluginNamespace() const noexcept
 }
 
 // Return the DataType of the plugin output at the requested index.
-DataType DetectionOutput::getOutputDataType(int index, const nvinfer1::DataType* inputTypes, int nbInputs) const noexcept
+DataType DetectionOutput::getOutputDataType(
+    int index, const nvinfer1::DataType* inputTypes, int nbInputs) const noexcept
 {
     // Two outputs
     ASSERT(index == 0 || index == 1);
     ASSERT(inputTypes[0] == inputTypes[1] && inputTypes[2] == inputTypes[1]);
     // topDetections
-    if (index == 0)
-    {
-        return inputTypes[0];
-    }
+    // if (index == 0)
+    // {
+    //     return inputTypes[0];
+    // }
     // keepCount: use kFLOAT instead as they have same sizeof(type)
     ASSERT(sizeof(int) == sizeof(float));
     return DataType::kFLOAT;
 }
 
-DataType DetectionOutputDynamic::getOutputDataType(int index, const nvinfer1::DataType* inputTypes, int nbInputs) const noexcept
+DataType DetectionOutputDynamic::getOutputDataType(
+    int index, const nvinfer1::DataType* inputTypes, int nbInputs) const noexcept
 {
     // Two outputs
     ASSERT(index == 0 || index == 1);
     ASSERT(inputTypes[0] == inputTypes[1] && inputTypes[2] == inputTypes[1]);
     // topDetections
-    if (index == 0)
-    {
-        return inputTypes[0];
-    }
+    // if (index == 0)
+    // {
+    //     return inputTypes[0];
+    // }
     // keepCount: use kFLOAT instead as they have same sizeof(type)
     ASSERT(sizeof(int) == sizeof(float));
     return DataType::kFLOAT;
@@ -477,7 +520,11 @@ void DetectionOutput::configurePlugin(const Dims* inputDims, int nbInputs, const
     const DataType* inputTypes, const DataType* outputTypes, const bool* inputIsBroadcast,
     const bool* outputIsBroadcast, PluginFormat floatFormat, int maxBatchSize) noexcept
 {
-    ASSERT(nbInputs == 3);
+    ASSERT(nbInputs == 3 || nbInputs == 5);
+
+    if (nbInputs == 5)
+        _ARM = true;
+
     ASSERT(nbOutputs == 2);
 
     // Verify all the input dimensions
@@ -514,7 +561,11 @@ void DetectionOutput::configurePlugin(const Dims* inputDims, int nbInputs, const
 void DetectionOutputDynamic::configurePlugin(
     const DynamicPluginTensorDesc* in, int nbInputs, const DynamicPluginTensorDesc* out, int nbOutputs) noexcept
 {
-    ASSERT(nbInputs == 3);
+    ASSERT(nbInputs == 3 || nbInputs == 5);
+
+    if (nbInputs == 5)
+        _ARM = true;
+
     ASSERT(nbOutputs == 2);
 
     // Verify all the input dimensions
@@ -570,7 +621,8 @@ NMSBasePluginCreator::NMSBasePluginCreator()
     mPluginAttributes.emplace_back(PluginField("keepTopK", nullptr, PluginFieldType::kINT32, 1));
     mPluginAttributes.emplace_back(PluginField("confidenceThreshold", nullptr, PluginFieldType::kFLOAT32, 1));
     mPluginAttributes.emplace_back(PluginField("nmsThreshold", nullptr, PluginFieldType::kFLOAT32, 1));
-    mPluginAttributes.emplace_back(PluginField("inputOrder", nullptr, PluginFieldType::kINT32, 3));
+    mPluginAttributes.emplace_back(PluginField("objectnessScore", nullptr, PluginFieldType::kFLOAT32, 1));
+    mPluginAttributes.emplace_back(PluginField("inputOrder", nullptr, PluginFieldType::kINT32, 5));
     mPluginAttributes.emplace_back(PluginField("confSigmoid", nullptr, PluginFieldType::kINT32, 1));
     mPluginAttributes.emplace_back(PluginField("isNormalized", nullptr, PluginFieldType::kINT32, 1));
     mPluginAttributes.emplace_back(PluginField("codeType", nullptr, PluginFieldType::kINT32, 1));
@@ -664,6 +716,11 @@ IPluginV2Ext* NMSPluginCreator::createPlugin(const char* name, const PluginField
             ASSERT(fields[i].type == PluginFieldType::kFLOAT32);
             params.nmsThreshold = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
         }
+        else if (!strcmp(attrName, "objectnessScore"))
+        {
+            ASSERT(fields[i].type == PluginFieldType::kFLOAT32);
+            params.objectnessScore = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
+        }
         else if (!strcmp(attrName, "confSigmoid"))
         {
             params.confSigmoid = static_cast<int>(*(static_cast<const int*>(fields[i].data)));
@@ -761,6 +818,11 @@ IPluginV2DynamicExt* NMSDynamicPluginCreator::createPlugin(const char* name, con
             ASSERT(fields[i].type == PluginFieldType::kFLOAT32);
             params.nmsThreshold = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
         }
+        else if (!strcmp(attrName, "objectnessScore"))
+        {
+            ASSERT(fields[i].type == PluginFieldType::kFLOAT32);
+            params.objectnessScore = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
+        }
         else if (!strcmp(attrName, "confSigmoid"))
         {
             params.confSigmoid = static_cast<int>(*(static_cast<const int*>(fields[i].data)));
diff --git a/plugin/nmsPlugin/nmsPlugin.h b/plugin/nmsPlugin/nmsPlugin.h
index 35b9d75..5229f0f 100644
--- a/plugin/nmsPlugin/nmsPlugin.h
+++ b/plugin/nmsPlugin/nmsPlugin.h
@@ -32,7 +32,7 @@ class DetectionOutput : public IPluginV2Ext
 public:
     DetectionOutput(DetectionOutputParameters param);
 
-    DetectionOutput(DetectionOutputParameters param, int C1, int C2, int numPriors);
+    DetectionOutput(DetectionOutputParameters param, int C1, int C2, int numPriors, bool ARM);
 
     DetectionOutput(const void* data, size_t length);
 
@@ -92,13 +92,14 @@ private:
     DataType mType;
     int32_t mScoreBits;
     std::string mPluginNamespace;
+    bool _ARM = false;
 };
 
 class DetectionOutputDynamic : public IPluginV2DynamicExt
 {
 public:
     DetectionOutputDynamic(DetectionOutputParameters param);
-    DetectionOutputDynamic(DetectionOutputParameters param, int C1, int C2, int numPriors);
+    DetectionOutputDynamic(DetectionOutputParameters param, int C1, int C2, int numPriors, bool ARM);
     DetectionOutputDynamic(const void* data, size_t length);
     ~DetectionOutputDynamic() override = default;
 
@@ -137,6 +138,7 @@ private:
     DataType mType;
     int32_t mScoreBits;
     std::string mPluginNamespace;
+    bool _ARM = false;
 };
 
 class NMSBasePluginCreator : public BaseCreator
