diff --git a/include/NvInferPluginUtils.h b/include/NvInferPluginUtils.h
index 1e47d5a..7688e08 100644
--- a/include/NvInferPluginUtils.h
+++ b/include/NvInferPluginUtils.h
@@ -154,9 +154,9 @@ struct DetectionOutputParameters
 {
     bool shareLocation, varianceEncodedInTarget;
     int32_t backgroundLabelId, numClasses, topK, keepTopK;
-    float confidenceThreshold, nmsThreshold;
+    float confidenceThreshold, nmsThreshold, objectnessScore;
     CodeTypeSSD codeType;
-    int32_t inputOrder[3];
+    int32_t inputOrder[5];
     bool confSigmoid;
     bool isNormalized;
     bool isBatchAgnostic{true};
diff --git a/parsers/caffe/caffeParser/caffeParser.cpp b/parsers/caffe/caffeParser/caffeParser.cpp
index d447c5c..9ad6b65 100644
--- a/parsers/caffe/caffeParser/caffeParser.cpp
+++ b/parsers/caffe/caffeParser/caffeParser.cpp
@@ -196,12 +196,19 @@ std::vector<nvinfer1::PluginField> CaffeParser::parseDetectionOutputParam(const
     *nmsThreshold = nmsp.nms_threshold();
     f.emplace_back("nmsThreshold", nmsThreshold, PluginFieldType::kFLOAT32, 1);
 
+    // objecteness score for ARM
+    auto* objectnessScore = allocMemory<float>();
+    *objectnessScore = p.objectness_score();
+    f.emplace_back("objectnessScore", objectnessScore, PluginFieldType::kFLOAT32, 1);
+
     // input order = {0, 1, 2} in Caffe
-    int* inputOrder = allocMemory<int32_t>(3);
+    int* inputOrder = allocMemory<int32_t>(5);
     inputOrder[0] = 0;
     inputOrder[1] = 1;
     inputOrder[2] = 2;
-    f.emplace_back("inputOrder", inputOrder, PluginFieldType::kINT32, 3);
+    inputOrder[3] = 3;
+    inputOrder[4] = 4;
+    f.emplace_back("inputOrder", inputOrder, PluginFieldType::kINT32, 5);
 
     // confSigmoid = false for Caffe
     int* confSigmoid = allocMemory<int32_t>();
diff --git a/parsers/caffe/proto/trtcaffe.proto b/parsers/caffe/proto/trtcaffe.proto
index 059f932..0ef9b6b 100644
--- a/parsers/caffe/proto/trtcaffe.proto
+++ b/parsers/caffe/proto/trtcaffe.proto
@@ -980,6 +980,8 @@ message DetectionOutputParameter {
   // Only consider detections whose confidences are larger than a threshold.
   // If not provided, consider all boxes.
   optional float confidence_threshold = 9;
+  // the objectness score is used for the anchor refinement module to filter easy negative anchor.
+  optional float objectness_score = 13 [default = 0.01];
   // If true, visualize the detection results.
   optional bool visualize = 10 [default = false];
   // The threshold used to visualize the detection results.
diff --git a/plugin/common/kernel.h b/plugin/common/kernel.h
index 5d645a1..32e70d8 100644
--- a/plugin/common/kernel.h
+++ b/plugin/common/kernel.h
@@ -43,8 +43,9 @@ pluginStatus_t allClassNMS(cudaStream_t stream, int num, int num_classes, int nu
 
 pluginStatus_t detectionInference(cudaStream_t stream, int N, int C1, int C2, bool shareLocation,
     bool varianceEncodedInTarget, int backgroundLabelId, int numPredsPerClass, int numClasses, int topK, int keepTopK,
-    float confidenceThreshold, float nmsThreshold, CodeTypeSSD codeType, DataType DT_BBOX, const void* locData,
-    const void* priorData, DataType DT_SCORE, const void* confData, void* keepCount, void* topDetections,
+    float confidenceThreshold, float nmsThreshold, float objectnessScore, CodeTypeSSD codeType, DataType DT_BBOX, const void* locData,
+    const void* priorData, DataType DT_SCORE, const void* confData, const void* arm_conf_data,
+    const void* arm_loc_data, void* keepCount, void* topDetections,
     void* workspace, bool isNormalized = true, bool confSigmoid = false, int scoreBits = 16,
     const bool isBatchAgnostic = true);
 
@@ -81,13 +82,16 @@ const char* cublasGetErrorString(cublasStatus_t error);
 pluginStatus_t permuteData(cudaStream_t stream, int nthreads, int num_classes, int num_data, int num_dim,
     DataType DT_DATA, bool confSigmoid, const void* data, void* new_data);
 
+pluginStatus_t OSPermuteData(cudaStream_t stream, int nthreads, int num_classes, int num_data, int num_dim,
+    DataType DT_DATA, bool confSigmoid, const void* data, const void* arm_data, float objectness_score, void* new_data);
+
 size_t detectionForwardPreNMSSize(int N, int C2);
 
 size_t detectionForwardPostNMSSize(int N, int numClasses, int topK);
 
 pluginStatus_t decodeBBoxes(cudaStream_t stream, int nthreads, CodeTypeSSD code_type, bool variance_encoded_in_target,
     int num_priors, bool share_location, int num_loc_classes, int background_label_id, bool clip_bbox, DataType DT_BBOX,
-    const void* loc_data, const void* prior_data, void* bbox_data, const bool batch_agnostic);
+    const void* loc_data, const void* prior_data, const void* arm_loc_data, void* bbox_data, const bool batch_agnostic);
 
 size_t normalizePluginWorkspaceSize(bool acrossSpatial, int C, int H, int W);
 
diff --git a/plugin/common/kernels/decodeBBoxes.cu b/plugin/common/kernels/decodeBBoxes.cu
index f49d004..b035418 100644
--- a/plugin/common/kernels/decodeBBoxes.cu
+++ b/plugin/common/kernels/decodeBBoxes.cu
@@ -286,6 +286,132 @@ __launch_bounds__(nthds_per_cta)
     }
 }
 
+template <typename T_BBOX, unsigned nthds_per_cta>
+__launch_bounds__(nthds_per_cta)
+    __global__ void CasReg_decodeBBoxes_kernel(
+        const int nthreads,
+        const CodeTypeSSD code_type,
+        const bool variance_encoded_in_target,
+        const int num_priors,
+        const bool share_location,
+        const int num_loc_classes,
+        const int background_label_id,
+        const bool clip_bbox,
+        const T_BBOX* loc_data,
+        const T_BBOX* prior_data,
+        T_BBOX* bbox_data)
+{
+    for (int index = blockIdx.x * nthds_per_cta + threadIdx.x; index < nthreads; index += nthds_per_cta * gridDim.x)
+    {
+        const int i = index % 4;
+        const int c = (index / 4) % num_loc_classes;
+        const int d = (index / 4 / num_loc_classes) % num_priors;
+        if (!share_location && c == background_label_id)
+        {
+            // Ignore background class if not share_location.
+            return;
+        }
+        const int pi = d * 4;
+        const int vi = pi + num_priors * 4;
+        if (code_type == CodeTypeSSD::CORNER)
+        {
+            if (variance_encoded_in_target)
+            {
+                // variance is encoded in target, we simply need to add the offset
+                // predictions.
+                bbox_data[index] = bbox_data[index] + loc_data[index];
+            }
+            else
+            {
+                // variance is encoded in bbox, we need to scale the offset accordingly.
+                bbox_data[index] = bbox_data[index] + loc_data[index] * prior_data[vi + i];
+            }
+        }
+        else if (code_type == CodeTypeSSD::CENTER_SIZE)
+        {
+            const T_BBOX p_xmin = bbox_data[index - i];
+            const T_BBOX p_ymin = bbox_data[index - i + 1];
+            const T_BBOX p_xmax = bbox_data[index - i + 2];
+            const T_BBOX p_ymax = bbox_data[index - i + 3];
+            const T_BBOX prior_width = p_xmax - p_xmin;
+            const T_BBOX prior_height = p_ymax - p_ymin;
+            const T_BBOX prior_center_x = (p_xmin + p_xmax) / 2.;
+            const T_BBOX prior_center_y = (p_ymin + p_ymax) / 2.;
+
+            const T_BBOX xmin = loc_data[index - i];
+            const T_BBOX ymin = loc_data[index - i + 1];
+            const T_BBOX xmax = loc_data[index - i + 2];
+            const T_BBOX ymax = loc_data[index - i + 3];
+
+            T_BBOX decode_bbox_center_x, decode_bbox_center_y;
+            T_BBOX decode_bbox_width, decode_bbox_height;
+            if (variance_encoded_in_target)
+            {
+                // variance is encoded in target, we simply need to retore the offset
+                // predictions.
+                decode_bbox_center_x = xmin * prior_width + prior_center_x;
+                decode_bbox_center_y = ymin * prior_height + prior_center_y;
+                decode_bbox_width = exp(xmax) * prior_width;
+                decode_bbox_height = exp(ymax) * prior_height;
+            }
+            else
+            {
+                // variance is encoded in bbox, we need to scale the offset accordingly.
+                decode_bbox_center_x = prior_data[vi] * xmin * prior_width + prior_center_x;
+                decode_bbox_center_y = prior_data[vi + 1] * ymin * prior_height + prior_center_y;
+                decode_bbox_width = exp(prior_data[vi + 2] * xmax) * prior_width;
+                decode_bbox_height = exp(prior_data[vi + 3] * ymax) * prior_height;
+            }
+
+            switch (i)
+            {
+            case 0: bbox_data[index] = decode_bbox_center_x - decode_bbox_width / 2.; break;
+            case 1: bbox_data[index] = decode_bbox_center_y - decode_bbox_height / 2.; break;
+            case 2: bbox_data[index] = decode_bbox_center_x + decode_bbox_width / 2.; break;
+            case 3: bbox_data[index] = decode_bbox_center_y + decode_bbox_height / 2.; break;
+            }
+        }
+        else if (code_type == CodeTypeSSD::CORNER_SIZE)
+        {
+            const T_BBOX p_xmin = bbox_data[index - i];
+            const T_BBOX p_ymin = bbox_data[index - i + 1];
+            const T_BBOX p_xmax = bbox_data[index - i + 2];
+            const T_BBOX p_ymax = bbox_data[index - i + 3];
+            const T_BBOX prior_width = p_xmax - p_xmin;
+            const T_BBOX prior_height = p_ymax - p_ymin;
+            T_BBOX p_size;
+            if (i == 0 || i == 2)
+            {
+                p_size = prior_width;
+            }
+            else
+            {
+                p_size = prior_height;
+            }
+            if (variance_encoded_in_target)
+            {
+                // variance is encoded in target, we simply need to add the offset
+                // predictions.
+                bbox_data[index] = bbox_data[index] + loc_data[index] * p_size;
+            }
+            else
+            {
+                // variance is encoded in bbox, we need to scale the offset accordingly.
+                bbox_data[index] = bbox_data[index] + loc_data[index] * prior_data[vi + i] * p_size;
+            }
+        }
+        else
+        {
+            // Unknown code type.
+        }
+        if (clip_bbox)
+        {
+            bbox_data[index] = max(min(bbox_data[index], T_BBOX(1.)), T_BBOX(0.));
+        }
+    }
+}
+
+
 template <typename T_BBOX>
 pluginStatus_t decodeBBoxes_gpu(
     cudaStream_t stream,
@@ -299,16 +425,32 @@ pluginStatus_t decodeBBoxes_gpu(
     const bool clip_bbox,
     const void* loc_data,
     const void* prior_data,
+    const void* arm_loc_data,
     void* bbox_data,
     const bool batch_agnostic)
 {
     const int BS = 512;
     const int GS = (nthreads + BS - 1) / BS;
-    decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>(nthreads, code_type, variance_encoded_in_target,
-                                                           num_priors, share_location, num_loc_classes,
-                                                           background_label_id, clip_bbox,
-                                                           (const T_BBOX*) loc_data, (const T_BBOX*) prior_data,
-                                                           (T_BBOX*) bbox_data, batch_agnostic);
+    if (arm_loc_data == NULL)
+       decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>
+         (nthreads, code_type, variance_encoded_in_target,
+          num_priors, share_location, num_loc_classes,
+          background_label_id, clip_bbox,
+          (const T_BBOX*) loc_data, (const T_BBOX*) prior_data,
+          (T_BBOX*) bbox_data, batch_agnostic);
+    else
+    {
+         decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>
+           (nthreads, code_type, variance_encoded_in_target,
+            num_priors, share_location, num_loc_classes, background_label_id, clip_bbox,
+            (const T_BBOX*) arm_loc_data,
+            (const T_BBOX*) prior_data, (T_BBOX*) bbox_data, batch_agnostic);
+         CasReg_decodeBBoxes_kernel<T_BBOX, BS><<<GS, BS, 0, stream>>>
+           (nthreads, code_type, variance_encoded_in_target,
+            num_priors, share_location, num_loc_classes, background_label_id,
+            clip_bbox, (const T_BBOX*) loc_data,
+            (const T_BBOX*) prior_data, (T_BBOX*) bbox_data);
+    }
     CSC(cudaGetLastError(), STATUS_FAILURE);
     return STATUS_SUCCESS;
 }
@@ -325,6 +467,7 @@ typedef pluginStatus_t (*dbbFunc)(cudaStream_t,
                                const bool,
                                const void*,
                                const void*,
+                               const void*,
                                void*,
                                const bool);
 
@@ -348,9 +491,8 @@ struct dbbLaunchConfig
     }
 };
 
-static std::array<dbbLaunchConfig, 2> dbbLCOptions = {
-    dbbLaunchConfig(DataType::kFLOAT, decodeBBoxes_gpu<float>),
-    dbbLaunchConfig(DataType::kHALF, decodeBBoxes_gpu<__half>)
+static std::array<dbbLaunchConfig, 1> dbbLCOptions = {
+    dbbLaunchConfig(DataType::kFLOAT, decodeBBoxes_gpu<float>)
 };
 
 pluginStatus_t decodeBBoxes(
@@ -366,6 +508,7 @@ pluginStatus_t decodeBBoxes(
     const DataType DT_BBOX,
     const void* loc_data,
     const void* prior_data,
+	const void* arm_loc_data,
     void* bbox_data,
     const bool batch_agnostic)
 {
@@ -386,6 +529,7 @@ pluginStatus_t decodeBBoxes(
                                           clip_bbox,
                                           loc_data,
                                           prior_data,
+                                          arm_loc_data,
                                           bbox_data,
                                           batch_agnostic);
         }
diff --git a/plugin/common/kernels/detectionForward.cu b/plugin/common/kernels/detectionForward.cu
index 079fb61..ff3e3fb 100644
--- a/plugin/common/kernels/detectionForward.cu
+++ b/plugin/common/kernels/detectionForward.cu
@@ -20,9 +20,9 @@
 pluginStatus_t detectionInference(cudaStream_t stream, const int N, const int C1, const int C2,
     const bool shareLocation, const bool varianceEncodedInTarget, const int backgroundLabelId,
     const int numPredsPerClass, const int numClasses, const int topK, const int keepTopK,
-    const float confidenceThreshold, const float nmsThreshold, const CodeTypeSSD codeType, const DataType DT_BBOX,
-    const void* locData, const void* priorData, const DataType DT_SCORE, const void* confData, void* keepCount,
-    void* topDetections, void* workspace, bool isNormalized, bool confSigmoid, int scoreBits,
+    const float confidenceThreshold, const float nmsThreshold, const float objectnessScore, const CodeTypeSSD codeType, const DataType DT_BBOX,
+    const void* locData, const void* priorData, const DataType DT_SCORE, const void* confData, const void* arm_confData,   const void* arm_locData,
+    void* keepCount, void* topDetections, void* workspace, bool isNormalized, bool confSigmoid, int scoreBits,
     const bool isBatchAgnostic)
 {
     // Batch size * number bbox per sample * 4 = total number of bounding boxes * 4
@@ -51,6 +51,7 @@ pluginStatus_t detectionInference(cudaStream_t stream, const int N, const int C1
                                       clipBBox,
                                       DT_BBOX,
                                       locData,
+                                      arm_locData,
                                       priorData,
                                       bboxDataRaw,
                                       isBatchAgnostic);
@@ -106,15 +107,29 @@ pluginStatus_t detectionInference(cudaStream_t stream, const int N, const int C1
      * After permutation, confData format:
      * [batch_size, numClasses, numPredsPerClass, 1]
      */
-    status = permuteData(stream,
-                         numScores,
-                         numClasses,
-                         numPredsPerClass,
-                         1,
-                         DT_SCORE,
-                         confSigmoid,
-                         confData,
-                         scores);
+    if (arm_confData == NULL)
+        status = permuteData(stream,
+                             numScores,
+                             numClasses,
+                             numPredsPerClass,
+                             1,
+                             DT_SCORE,
+                             confSigmoid,
+                             confData,
+                             scores);
+    else
+        status = OSPermuteData(stream,
+                             numScores,
+                             numClasses,
+                             numPredsPerClass,
+                             1,
+                             DataType::kFLOAT,
+                             confSigmoid,
+                             confData,
+                             arm_confData,
+                             objectnessScore,
+                             scores);
+
     ASSERT_FAILURE(status == STATUS_SUCCESS);
 
     size_t indicesSize = detectionForwardPreNMSSize(N, C2);
@@ -203,12 +218,15 @@ namespace plugin
     const int keepTopK,
     const float confidenceThreshold,
     const float nmsThreshold,
+	const float objectnessScore,
     const CodeTypeSSD codeType,
     const DataType DT_BBOX,
     const void* locData,
     const void* priorData,
     const DataType DT_SCORE,
     const void* confData,
+	const void* arm_confData,
+	const void* arm_locData,
     void* keepCount,
     void* topDetections,
     void* workspace,
@@ -244,6 +262,7 @@ namespace plugin
                                       DT_BBOX,
                                       locData,
                                       priorData,
+                                      arm_locData,
                                       bboxDataRaw,
                                       isBatchAgnostic);
 
@@ -298,15 +317,29 @@ namespace plugin
      * After permutation, confData format:
      * [batch_size, numClasses, numPredsPerClass, 1]
      */
-    status = permuteData(stream,
-                         numScores,
-                         numClasses,
-                         numPredsPerClass,
-                         1,
-                         DT_SCORE,
-                         confSigmoid,
-                         confData,
-                         scores);
+    if (arm_confData == NULL)
+      status = permuteData(stream,
+                           numScores,
+                           numClasses,
+                           numPredsPerClass,
+                           1,
+                           DT_SCORE,
+                           confSigmoid,
+                           confData,
+                           scores);
+    else
+      status = OSPermuteData(stream,
+                           numScores,
+                           numClasses,
+                           numPredsPerClass,
+                           1,
+                           DataType::kFLOAT,
+                           confSigmoid,
+                           confData,
+                           arm_confData,
+                           objectnessScore,
+                           scores);
+
     ASSERT_FAILURE(status == STATUS_SUCCESS);
 
     size_t indicesSize = detectionForwardPreNMSSize(N, C2);
diff --git a/plugin/common/kernels/permuteData.cu b/plugin/common/kernels/permuteData.cu
index c6eef13..526ebc9 100644
--- a/plugin/common/kernels/permuteData.cu
+++ b/plugin/common/kernels/permuteData.cu
@@ -17,6 +17,139 @@
 #include "common/kernel.h"
 #include <array>
 
+template <typename Dtype, unsigned nthds_per_cta>
+__launch_bounds__(nthds_per_cta)
+    __global__ void OSPermuteData_kernel(
+        const int nthreads,
+        const int num_classes,
+        const int num_data,
+        const int num_dim,
+        bool confSigmoid,
+        const Dtype* data,
+		const Dtype* arm_data,
+		float objectness_score,
+        Dtype* new_data)
+{
+    // data format: [batch_size, num_data, num_classes, num_dim]
+    for (int index = blockIdx.x * nthds_per_cta + threadIdx.x;
+         index < nthreads;
+         index += nthds_per_cta * gridDim.x)
+    {
+        const int i = index % num_dim;
+        const int c = (index / num_dim) % num_classes;
+        const int d = (index / num_dim / num_classes) % num_data;
+        const int n = index / num_dim / num_classes / num_data;
+        const int new_index = ((n * num_classes + c) * num_data + d) * num_dim + i;
+
+		const int arm_index = ((n * num_data + d) * 2 + 1) * num_dim + i;
+		if (arm_data[arm_index] < objectness_score)
+		  {
+			if (c==0)
+			  new_data[new_index] = 1.0;
+			else
+			  new_data[new_index] = 0.0;
+		  }
+		else
+		  {
+			float result = data[index];
+			if (confSigmoid)
+			  result = exp(result) / (1 + exp(result));
+			new_data[new_index] = result;
+		  }
+    }
+    // new data format: [batch_size, num_classes, num_data, num_dim]
+}
+
+template <typename Dtype>
+pluginStatus_t OSPermuteData_gpu(
+    cudaStream_t stream,
+    const int nthreads,
+    const int num_classes,
+    const int num_data,
+    const int num_dim,
+    bool confSigmoid,
+    const void* data,
+	const void* arm_data,
+	float objectness_score,
+    void* new_data)
+{
+    const int BS = 512;
+    const int GS = (nthreads + BS - 1) / BS;
+    OSPermuteData_kernel<Dtype, BS><<<GS, BS, 0, stream>>>(nthreads, num_classes, num_data, num_dim, confSigmoid,
+                                                         (const Dtype*) data, (const Dtype*) arm_data, objectness_score, (Dtype*) new_data);
+    CSC(cudaGetLastError(), STATUS_FAILURE);
+    return STATUS_SUCCESS;
+}
+// permuteData LAUNCH CONFIG
+typedef pluginStatus_t (*ospdFunc)(cudaStream_t,
+								   const int,
+								   const int,
+								   const int,
+								   const int,
+								   bool,
+								   const void*,
+								   const void*,
+								   const float,
+								   void*);
+
+struct ospdLaunchConfig
+{
+    DataType t_data;
+    ospdFunc function;
+
+    ospdLaunchConfig(DataType t_data)
+        : t_data(t_data)
+    {
+    }
+    ospdLaunchConfig(DataType t_data, ospdFunc function)
+        : t_data(t_data)
+        , function(function)
+    {
+    }
+    bool operator==(const ospdLaunchConfig& other)
+    {
+        return t_data == other.t_data;
+    }
+};
+
+static std::array<ospdLaunchConfig,1> ospdLCOptions = {
+  ospdLaunchConfig(DataType::kFLOAT, OSPermuteData_gpu<float>)
+};
+
+pluginStatus_t OSPermuteData(cudaStream_t stream,
+                        const int nthreads,
+                        const int num_classes,
+                        const int num_data,
+                        const int num_dim,
+                        const DataType DT_DATA,
+                        bool confSigmoid,
+                        const void* data,
+						const void * arm_data,
+						float objectness_score,
+                        void* new_data)
+{
+    ospdLaunchConfig lc = ospdLaunchConfig(DT_DATA);
+    for (unsigned i = 0; i < ospdLCOptions.size(); ++i)
+    {
+        if (lc == ospdLCOptions[i])
+        {
+            DEBUG_PRINTF("permuteData kernel %d\n", i);
+            return ospdLCOptions[i].function(stream,
+										   nthreads,
+										   num_classes,
+										   num_data,
+										   num_dim,
+										   confSigmoid,
+										   data,
+										   arm_data,
+										 objectness_score,
+										   new_data);
+        }
+    }
+    return STATUS_BAD_PARAM;
+}
+
+
 template <typename Dtype, unsigned nthds_per_cta>
 __launch_bounds__(nthds_per_cta) __global__ void permuteData_kernel(const int nthreads, const int num_classes,
     const int num_data, const int num_dim, bool confSigmoid, const Dtype* data, Dtype* new_data)
@@ -80,8 +213,9 @@ struct pdLaunchConfig
     }
 };
 
-static std::array<pdLaunchConfig, 2> pdLCOptions = {
-    pdLaunchConfig(DataType::kFLOAT, permuteData_gpu<float>), pdLaunchConfig(DataType::kHALF, permuteData_gpu<__half>)};
+static std::array<pdLaunchConfig, 1> pdLCOptions = {
+    pdLaunchConfig(DataType::kFLOAT, permuteData_gpu<float>)
+};
 
 pluginStatus_t permuteData(cudaStream_t stream, const int nthreads, const int num_classes, const int num_data,
     const int num_dim, const DataType DT_DATA, bool confSigmoid, const void* data, void* new_data)
diff --git a/plugin/nmsPlugin/nmsPlugin.cpp b/plugin/nmsPlugin/nmsPlugin.cpp
index 2aff8b7..6ac76d3 100644
--- a/plugin/nmsPlugin/nmsPlugin.cpp
+++ b/plugin/nmsPlugin/nmsPlugin.cpp
@@ -45,6 +45,7 @@ DetectionOutput::DetectionOutput(DetectionOutputParameters params)
     , numPriors(0)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(false)
 {
 }
 
@@ -55,26 +56,30 @@ DetectionOutputDynamic::DetectionOutputDynamic(DetectionOutputParameters params)
     , numPriors(0)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(false)
 {
 }
 
-DetectionOutput::DetectionOutput(DetectionOutputParameters params, int C1, int C2, int numPriors)
+DetectionOutput::DetectionOutput(DetectionOutputParameters params, int C1, int C2, int numPriors, bool ARM)
     : param(params)
     , C1(C1)
     , C2(C2)
     , numPriors(numPriors)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(ARM)
 {
 }
 
-DetectionOutputDynamic::DetectionOutputDynamic(DetectionOutputParameters params, int C1, int C2, int numPriors)
+DetectionOutputDynamic::DetectionOutputDynamic(
+    DetectionOutputParameters params, int C1, int C2, int numPriors, bool ARM)
     : param(params)
     , C1(C1)
     , C2(C2)
     , numPriors(numPriors)
     , mType(DataType::kFLOAT)
     , mScoreBits(16)
+    , _ARM(ARM)
 {
 }
 
@@ -91,6 +96,11 @@ DetectionOutput::DetectionOutput(const void* data, size_t length)
     C2 = read<int>(d);
     // Number of bounding boxes per sample
     numPriors = read<int>(d);
+    int arm = read<int>(d);
+    if (arm == 0)
+        _ARM = false;
+    else
+        _ARM = true;
     // data type of this plugin
     mType = read<DataType>(d);
     // mScoreBits
@@ -110,6 +120,11 @@ DetectionOutputDynamic::DetectionOutputDynamic(const void* data, size_t length)
     C2 = read<int>(d);
     // Number of bounding boxes per sample
     numPriors = read<int>(d);
+    int arm = read<int>(d);
+    if (arm == 0)
+        _ARM = false;
+    else
+        _ARM = true;
     // data type of this plugin
     mType = read<DataType>(d);
     // mScoreBits
@@ -146,7 +161,7 @@ void DetectionOutputDynamic::terminate() noexcept {}
 // Returns output dimensions at given index
 Dims DetectionOutput::getOutputDimensions(int index, const Dims* inputs, int nbInputDims) noexcept
 {
-    PLUGIN_ASSERT(nbInputDims == 3);
+    PLUGIN_ASSERT(nbInputDims == 3 || nbInputDims == 5);
     PLUGIN_ASSERT(index == 0 || index == 1);
     // Output dimensions
     // index 0 : Dimensions 1x param.keepTopK x 7
@@ -161,7 +176,7 @@ Dims DetectionOutput::getOutputDimensions(int index, const Dims* inputs, int nbI
 DimsExprs DetectionOutputDynamic::getOutputDimensions(
     int outputIndex, const DimsExprs* inputs, int nbInputs, IExprBuilder& exprBuilder) noexcept
 {
-    PLUGIN_ASSERT(nbInputs == 3);
+    PLUGIN_ASSERT(nbInputs == 3 || nbInputs == 5);
     PLUGIN_ASSERT(outputIndex >= 0 && outputIndex < this->getNbOutputs());
     // loc data
     PLUGIN_ASSERT(inputs[0].nbDims == 4);
@@ -230,8 +245,16 @@ int DetectionOutput::enqueue(
 {
     // Input order {loc, conf, prior}
     const void* const locData = inputs[param.inputOrder[0]];
-    const void* const confData = inputs[param.inputOrder[1]];
-    const void* const priorData = inputs[param.inputOrder[2]];
+    const void* confData = inputs[param.inputOrder[1]];
+    const void* priorData = inputs[param.inputOrder[2]];
+    const void* arm_conf_data = NULL;
+    const void* arm_loc_data = NULL;
+
+    if (_ARM)
+    {
+        arm_conf_data = inputs[param.inputOrder[3]];
+        arm_loc_data = inputs[param.inputOrder[4]];
+    }
 
     // Output from plugin index 0: topDetections index 1: keepCount
     void* topDetections = outputs[0];
@@ -239,8 +262,9 @@ int DetectionOutput::enqueue(
 
     pluginStatus_t status = detectionInference(stream, batchSize, C1, C2, param.shareLocation,
         param.varianceEncodedInTarget, param.backgroundLabelId, numPriors, param.numClasses, param.topK, param.keepTopK,
-        param.confidenceThreshold, param.nmsThreshold, param.codeType, mType, locData, priorData, mType, confData,
-        keepCount, topDetections, workspace, param.isNormalized, param.confSigmoid, mScoreBits, param.isBatchAgnostic);
+        param.confidenceThreshold, param.nmsThreshold, param.objectnessScore, param.codeType, mType, locData, priorData,
+        mType, confData, arm_conf_data, arm_loc_data, keepCount, topDetections, workspace, param.isNormalized,
+        param.confSigmoid, mScoreBits, param.isBatchAgnostic);
     return status;
 }
 
@@ -249,8 +273,16 @@ int32_t DetectionOutputDynamic::enqueue(const PluginTensorDesc* inputDesc, const
 {
     // Input order {loc, conf, prior}
     const void* const locData = inputs[param.inputOrder[0]];
-    const void* const confData = inputs[param.inputOrder[1]];
-    const void* const priorData = inputs[param.inputOrder[2]];
+    const void* confData = inputs[param.inputOrder[1]];
+    const void* priorData = inputs[param.inputOrder[2]];
+    const void* arm_conf_data = NULL;
+    const void* arm_loc_data = NULL;
+
+    if (_ARM)
+    {
+        arm_conf_data = inputs[param.inputOrder[3]];
+        arm_loc_data = inputs[param.inputOrder[4]];
+    }
 
     // Output from plugin index 0: topDetections index 1: keepCount
     void* topDetections = outputs[0];
@@ -258,8 +290,9 @@ int32_t DetectionOutputDynamic::enqueue(const PluginTensorDesc* inputDesc, const
 
     pluginStatus_t status = detectionInference(stream, inputDesc[0].dims.d[0], C1, C2, param.shareLocation,
         param.varianceEncodedInTarget, param.backgroundLabelId, numPriors, param.numClasses, param.topK, param.keepTopK,
-        param.confidenceThreshold, param.nmsThreshold, param.codeType, mType, locData, priorData, mType, confData,
-        keepCount, topDetections, workspace, param.isNormalized, param.confSigmoid, mScoreBits, false);
+        param.confidenceThreshold, param.nmsThreshold, param.objectnessScore, param.codeType, mType, locData, priorData,
+        mType, confData, arm_conf_data, arm_loc_data, keepCount, topDetections, workspace, param.isNormalized,
+        param.confSigmoid, mScoreBits, false);
     return status;
 }
 
@@ -267,13 +300,13 @@ int32_t DetectionOutputDynamic::enqueue(const PluginTensorDesc* inputDesc, const
 size_t DetectionOutput::getSerializationSize() const noexcept
 {
     // DetectionOutputParameters, C1, C2, numPriors, mType, mScoreBits
-    return sizeof(DetectionOutputParameters) + sizeof(int) * 3 + sizeof(DataType) + sizeof(int32_t);
+    return sizeof(DetectionOutputParameters) + sizeof(int) * 4 + sizeof(DataType) + sizeof(int32_t);
 }
 
 size_t DetectionOutputDynamic::getSerializationSize() const noexcept
 {
     // DetectionOutputParameters, C1, C2, numPriors, mType, mScoreBits
-    return sizeof(DetectionOutputParameters) + sizeof(int) * 3 + sizeof(DataType) + sizeof(int32_t);
+    return sizeof(DetectionOutputParameters) + sizeof(int) * 4 + sizeof(DataType) + sizeof(int32_t);
 }
 
 // Serialization of plugin parameters
@@ -284,6 +317,10 @@ void DetectionOutput::serialize(void* buffer) const noexcept
     write(d, C1);
     write(d, C2);
     write(d, numPriors);
+    if (_ARM)
+        write(d, (int) 1);
+    else
+        write(d, (int) 0);
     write(d, mType);
     write(d, mScoreBits);
     PLUGIN_ASSERT(d == a + getSerializationSize());
@@ -296,6 +333,10 @@ void DetectionOutputDynamic::serialize(void* buffer) const noexcept
     write(d, C1);
     write(d, C2);
     write(d, numPriors);
+    if (_ARM)
+        write(d, (int) 1);
+    else
+        write(d, (int) 0);
     write(d, mType);
     write(d, mScoreBits);
     PLUGIN_ASSERT(d == a + getSerializationSize());
@@ -311,25 +352,28 @@ bool DetectionOutputDynamic::supportsFormatCombination(
     int pos, const PluginTensorDesc* inOut, int nbInputs, int nbOutputs) noexcept
 {
     // 3 inputs, 2 outputs, so 5 input/output in total
-    PLUGIN_ASSERT(0 <= pos && pos < 5);
+    PLUGIN_ASSERT(0 <= pos && pos < 7);
     const auto* in = inOut;
     const auto* out = inOut + nbInputs;
     const bool consistentFloatPrecision = (in[0].type == in[pos].type);
     switch (pos)
     {
     case 0:
-        return (in[0].type == DataType::kHALF || in[0].type == DataType::kFLOAT)
+        return (in[0].type == DataType::kFLOAT)
             && in[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
     case 1:
-        return (in[1].type == DataType::kHALF || in[1].type == DataType::kFLOAT)
+        return (in[1].type == DataType::kFLOAT)
             && in[1].format == PluginFormat::kLINEAR && consistentFloatPrecision;
     case 2:
-        return (in[2].type == DataType::kHALF || in[2].type == DataType::kFLOAT)
+        return (in[2].type == DataType::kFLOAT)
             && in[2].format == PluginFormat::kLINEAR && consistentFloatPrecision;
     case 3:
-        return (out[0].type == DataType::kHALF || out[0].type == DataType::kFLOAT)
-            && out[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
-    case 4: return out[1].type == DataType::kFLOAT && out[1].format == PluginFormat::kLINEAR;
+        return (in[3].type == DataType::kFLOAT) && in[3].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+    case 4:
+        return (in[4].type == DataType::kFLOAT) && in[4].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+    case 5:
+        return (out[0].type == DataType::kFLOAT) && out[0].format == PluginFormat::kLINEAR && consistentFloatPrecision;
+    case 6: return out[1].type == DataType::kFLOAT && out[1].format == PluginFormat::kLINEAR;
     }
     return false;
 }
@@ -383,7 +427,7 @@ IPluginV2Ext* DetectionOutput::clone() const noexcept
     try
     {
         // Create a new instance
-        auto* plugin = new DetectionOutput(param, C1, C2, numPriors);
+        auto* plugin = new DetectionOutput(param, C1, C2, numPriors, _ARM);
         plugin->mType = mType;
         // Set the namespace
         plugin->setPluginNamespace(mPluginNamespace.c_str());
@@ -403,7 +447,7 @@ IPluginV2DynamicExt* DetectionOutputDynamic::clone() const noexcept
     try
     {
         // Create a new instance
-        auto* plugin = new DetectionOutputDynamic(param, C1, C2, numPriors);
+        auto* plugin = new DetectionOutputDynamic(param, C1, C2, numPriors, _ARM);
         plugin->mType = mType;
         // Set the namespace
         plugin->setPluginNamespace(mPluginNamespace.c_str());
@@ -447,26 +491,25 @@ DataType DetectionOutput::getOutputDataType(int index, const nvinfer1::DataType*
     PLUGIN_ASSERT(index == 0 || index == 1);
     PLUGIN_ASSERT(inputTypes[0] == inputTypes[1] && inputTypes[2] == inputTypes[1]);
     // topDetections
-    if (index == 0)
-    {
-        return inputTypes[0];
-    }
+    // if (index == 0)
+    // {
+    //    return inputTypes[0];
+    // }
     // keepCount: use kFLOAT instead as they have same sizeof(type)
     PLUGIN_ASSERT(sizeof(int) == sizeof(float));
     return DataType::kFLOAT;
 }
 
-DataType DetectionOutputDynamic::getOutputDataType(int index, const nvinfer1::DataType* inputTypes, int nbInputs) const
-    noexcept
+DataType DetectionOutputDynamic::getOutputDataType(int index, const nvinfer1::DataType* inputTypes, int nbInputs) const noexcept
 {
     // Two outputs
     PLUGIN_ASSERT(index == 0 || index == 1);
     PLUGIN_ASSERT(inputTypes[0] == inputTypes[1] && inputTypes[2] == inputTypes[1]);
     // topDetections
-    if (index == 0)
-    {
-        return inputTypes[0];
-    }
+    // if (index == 0)
+    // {
+    //    return inputTypes[0];
+    // }
     // keepCount: use kFLOAT instead as they have same sizeof(type)
     PLUGIN_ASSERT(sizeof(int) == sizeof(float));
     return DataType::kFLOAT;
@@ -496,9 +539,12 @@ void DetectionOutput::configurePlugin(const Dims* inputDims, int nbInputs, const
     const DataType* inputTypes, const DataType* outputTypes, const bool* inputIsBroadcast,
     const bool* outputIsBroadcast, PluginFormat floatFormat, int maxBatchSize) noexcept
 {
-    PLUGIN_ASSERT(nbInputs == 3);
+    PLUGIN_ASSERT(nbInputs == 3 || nbInputs == 5);
     PLUGIN_ASSERT(nbOutputs == 2);
 
+    if (nbInputs == 5)
+        _ARM = true;
+
     // Verify all the input dimensions
     for (int i = 0; i < nbInputs; i++)
     {
@@ -533,9 +579,12 @@ void DetectionOutput::configurePlugin(const Dims* inputDims, int nbInputs, const
 void DetectionOutputDynamic::configurePlugin(
     const DynamicPluginTensorDesc* in, int nbInputs, const DynamicPluginTensorDesc* out, int nbOutputs) noexcept
 {
-    PLUGIN_ASSERT(nbInputs == 3);
+    PLUGIN_ASSERT(nbInputs == 3 || nbInputs == 5);
     PLUGIN_ASSERT(nbOutputs == 2);
 
+    if (nbInputs == 5)
+        _ARM = true;
+
     // Verify all the input dimensions
     for (int i = 0; i < nbInputs; i++)
     {
@@ -589,7 +638,8 @@ NMSBasePluginCreator::NMSBasePluginCreator()
     mPluginAttributes.emplace_back(PluginField("keepTopK", nullptr, PluginFieldType::kINT32, 1));
     mPluginAttributes.emplace_back(PluginField("confidenceThreshold", nullptr, PluginFieldType::kFLOAT32, 1));
     mPluginAttributes.emplace_back(PluginField("nmsThreshold", nullptr, PluginFieldType::kFLOAT32, 1));
-    mPluginAttributes.emplace_back(PluginField("inputOrder", nullptr, PluginFieldType::kINT32, 3));
+    mPluginAttributes.emplace_back(PluginField("objectnessScore", nullptr, PluginFieldType::kFLOAT32, 1));
+    mPluginAttributes.emplace_back(PluginField("inputOrder", nullptr, PluginFieldType::kINT32, 5));
     mPluginAttributes.emplace_back(PluginField("confSigmoid", nullptr, PluginFieldType::kINT32, 1));
     mPluginAttributes.emplace_back(PluginField("isNormalized", nullptr, PluginFieldType::kINT32, 1));
     mPluginAttributes.emplace_back(PluginField("codeType", nullptr, PluginFieldType::kINT32, 1));
@@ -685,6 +735,11 @@ IPluginV2Ext* NMSPluginCreator::createPlugin(const char* name, const PluginField
                 PLUGIN_VALIDATE(fields[i].type == PluginFieldType::kFLOAT32);
                 params.nmsThreshold = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
             }
+            else if (!strcmp(attrName, "objectnessScore"))
+            {
+                PLUGIN_VALIDATE(fields[i].type == PluginFieldType::kFLOAT32);
+                params.objectnessScore = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
+            }
             else if (!strcmp(attrName, "confSigmoid"))
             {
                 params.confSigmoid = static_cast<int>(*(static_cast<const int*>(fields[i].data)));
@@ -790,6 +845,11 @@ IPluginV2DynamicExt* NMSDynamicPluginCreator::createPlugin(const char* name, con
                 PLUGIN_VALIDATE(fields[i].type == PluginFieldType::kFLOAT32);
                 params.nmsThreshold = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
             }
+            else if (!strcmp(attrName, "objectnessScore"))
+            {
+                PLUGIN_VALIDATE(fields[i].type == PluginFieldType::kFLOAT32);
+                params.objectnessScore = static_cast<float>(*(static_cast<const float*>(fields[i].data)));
+            }
             else if (!strcmp(attrName, "confSigmoid"))
             {
                 params.confSigmoid = static_cast<int>(*(static_cast<const int*>(fields[i].data)));
diff --git a/plugin/nmsPlugin/nmsPlugin.h b/plugin/nmsPlugin/nmsPlugin.h
index 5717e21..5846c5e 100644
--- a/plugin/nmsPlugin/nmsPlugin.h
+++ b/plugin/nmsPlugin/nmsPlugin.h
@@ -33,7 +33,7 @@ class DetectionOutput : public IPluginV2Ext
 public:
     DetectionOutput(DetectionOutputParameters param);
 
-    DetectionOutput(DetectionOutputParameters param, int C1, int C2, int numPriors);
+    DetectionOutput(DetectionOutputParameters param, int C1, int C2, int numPriors, bool ARM);
 
     DetectionOutput(const void* data, size_t length);
 
@@ -93,13 +93,14 @@ private:
     DataType mType;
     int32_t mScoreBits;
     std::string mPluginNamespace;
+    bool _ARM = false;
 };
 
 class DetectionOutputDynamic : public IPluginV2DynamicExt
 {
 public:
     DetectionOutputDynamic(DetectionOutputParameters param);
-    DetectionOutputDynamic(DetectionOutputParameters param, int C1, int C2, int numPriors);
+    DetectionOutputDynamic(DetectionOutputParameters param, int C1, int C2, int numPriors, bool ARM);
     DetectionOutputDynamic(const void* data, size_t length);
     ~DetectionOutputDynamic() override = default;
 
@@ -138,6 +139,7 @@ private:
     DataType mType;
     int32_t mScoreBits;
     std::string mPluginNamespace;
+    bool _ARM = false;
 };
 
 class NMSBasePluginCreator : public nvinfer1::pluginInternal::BaseCreator
